/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(fetch) {(function() {\r\n    let helpers = {\r\n        rndColor() {\r\n            return \"#\" + Math.floor( Math.random() * 0xFFFFFF ).toString(16);\r\n        }\r\n    };\r\n\r\n    let app = {\r\n        initialize() {\r\n            this.GCBlock = document.getElementById(\"GC-block\");\r\n            this.settingsBlock = document.getElementById(\"settings\");\r\n            this.zoomSelectEl = document.getElementById(\"zoom__select\");\r\n            this.errorBlock = document.getElementById(\"error-block\");\r\n\r\n            //можливі масштаби\r\n            this.scalesDictionary = [\r\n                {\r\n                    title: \"100px : 1 день\",    //текст що буде в елементі select\r\n                    timeLength: 1000*60*60*24,  //коефіцієнт що відповідає часу\r\n                    width: 100,                 //ширина комірки в px\r\n                    disabled: false              //чи доступний масштаб(якщо він занадто великий, то буде недоступним)\r\n                },\r\n                {title: \"50px : 1 день\", timeLength: 1000*60*60*24, width: 50, disabled: false},\r\n                {title: \"30px : 1 день\", timeLength: 1000*60*60*24, width: 30, disabled: false},\r\n                {title: \"20px : 1 день\", timeLength: 1000*60*60*24, width: 20, disabled: false},\r\n                {title: \"200px : 1 місяць\", timeLength: 1000*60*60*24*3, width: 200, disabled: false},\r\n                {title: \"100px : 1 місяць\", timeLength: 1000*60*60*24*3, width: 100, disabled: false},\r\n                {title: \"80px : 1 місяць\", timeLength: 1000*60*60*24*3, width: 80, disabled: false},\r\n                {title: \"50px : 1 місяць\", timeLength: 1000*60*60*24*3, width: 50, disabled: false}\r\n            ];\r\n            this.TASK_NAME_PADDING_K = 10;  //відступ на 10px біля імені для кожного рівня вкладеності\r\n\r\n            this.scaleIndex = null;\t    //індекс обраного масштабу; let scale = app.scalesDictionary[app.scaleIndex];\r\n            this.GCData = {             //дані про діаграму\r\n                startDate: null,        //початкова дата всієї діаграми\r\n                endDate: null,          //кінцева дата всієї діаграми\r\n                minInterval: null,      //найкоротший інтервал задачі\r\n                tasks: []               //модифікований масив задач що отримується з JSON\r\n                                        // містить ще task[i].level - рівень вкладеності(кількість батьків) task[i].intervas[j].color\r\n            };\r\n\r\n            this.getData('/tasks.json')\r\n                //.then( data => console.log('Gotten JSON with tasks: ', JSON.stringify(data)) )\r\n                .then(this.validateModelData)\r\n                .then(this.evaluateAppData)\r\n                .then(this.renderGanttChart)\r\n                .catch(this.renderError);\r\n\r\n            this.setUpListeners();\r\n        },\r\n\r\n        setUpListeners() {\r\n            //      this.form.addEventListener(\"submit\", this.submitForm);\r\n        },\r\n\r\n        getData(jsonURL){\r\n            return fetch(jsonURL)\r\n                .then(checkStatus)\r\n                .then(response => response.json() );\r\n\r\n            function checkStatus(response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response;\r\n                } else {\r\n                    var error = new Error(response.statusText);\r\n                    error.response = response;\r\n                    throw error;\r\n                }\r\n            }\r\n        },\r\n\r\n        //рекурсивно обходить масив tasks та для кожного елемента викликає cb\r\n        goThroughTasks(tasks, cb) {\r\n            let index = 0;\r\n            (function _goThroughTasks(tasks, cb, depth) {\r\n                for(let task of tasks) {\r\n                    ++index;\r\n                    cb(task, index, depth);\r\n                    if(task.subtasks && task.subtasks.length) {\r\n                        goThroughTasks(task.subtasks, cb, depth+1);\r\n                    }\r\n                }\r\n            }(tasks, cb, 0));\r\n        },\r\n\r\n        validateModelData(tasks) {\r\n            //перевірити все\r\n            if(!tasks )\r\n                throw new Error(\"Не отримано списку задач при спробі перевірити їх на коректність. \");\r\n            if(!(tasks instanceof Array))\r\n                throw new Error(\"Отримано некоректну структуру даних із задачами: очікувався масив.\");\r\n\r\n            let arrOfUniqueId = [];\r\n            app.goThroughTasks(tasks, (task, i) => {\r\n                //перевіряємо на унікальність id\r\n                if(arrOfUniqueId.includes(task.id))\r\n                    throw new Error(`Отримано некоректну структуру даних із задачами: повторюється ідентифікатор задач id=${task.id}.`);\r\n                arrOfUniqueId.push(task.id);\r\n\r\n                //перевіряємо на коректність дати\r\n                if(!task.intervals )\r\n                    throw new Error(`Отримано некоректну структуру даних із задачами: задача з id=${task.id} не має списку початковиї і кінцевих дат.`);\r\n\r\n                let invalidDate = task.intervals.some(taskDate => {\r\n                        let sd = new Date(taskDate.startDate),\r\n                            ed = new Date(taskDate.endDate);\r\n                        return sd === 'Invalid Date' || ed === 'Invalid Date';\r\n                    });\r\n                if(invalidDate)\r\n                    throw new Error(`Отримано некоректну структуру даних із задачами: задача з id=${task.id} має недопустиму дату.`);\r\n\r\n                if(!task.intervals.length && !task.subtasks.length)\r\n                    throw new Error(`Отримано некоректну структуру даних із задачами: для задачі з id=${task.id} має бути вказано не пустий список початкових і кінцевих дат, або не пустий список підзадач`);\r\n\r\n                task.intervals.forEach(taskDate => {\r\n                    if(new Date(taskDate.startDate) > new Date(taskDate.endDate))\r\n                        throw new Error(`Отримано некоректну структуру даних із задачами: у задачі з id=${task.id} дата початку більша за дату кінця.`);\r\n                });\r\n\r\n                task.intervals.forEach(taskDate => {\r\n                    if(new Date(taskDate.endDate) - new Date(taskDate.startDate) < 1000*60*60)\r\n                        throw new Error(`Отримано некоректну структуру даних із задачами: у задачі з id=${task.id} вказано занадто короткий інтервал. Програма не підтримує задачі з тривалістю менше 1 години.`);\r\n                });\r\n\r\n                //ToDo: перевірити чи підзадачі не виходять за діапазон тривалості батьківської задачі\r\n            });\r\n\r\n            return tasks\r\n        },\r\n\r\n        //розраховує та встановлює дані про стан додатку\r\n        evaluateAppData(tasks) {\r\n            let minDate = new Date(1000*60*60*24*30*12*1000),\r\n                maxDate = new Date(0),\r\n                minInterval = Infinity;\r\n\r\n            app.goThroughTasks(tasks, (task, i, depth) => {\r\n                task.intervals.forEach(interval => {\r\n                    if(minDate > interval.startDate)\r\n                        minDate = interval.startDate;\r\n                    if(maxDate < interval.endDate)\r\n                        maxDate = interval.endDate;\r\n                    let intervalLength = interval.endDate - interval.startDate;\r\n                    if(intervalLength < minInterval)\r\n                        minInterval = intervalLength;\r\n\r\n                    interval.color = helpers.rndColor();   //задаємо колір полоски для кожного інтервалу\r\n                });\r\n\r\n                task.level = depth;     //запам'ятовуємо рівень відступу(який кратний кількості батьків) для кожної задачі\r\n            });\r\n\r\n            //вираховуємо оптимальний та допустимі масштаби\r\n            this.scaleIndex = 0;\r\n            this.scalesDictionary.reduce((best, current, i)=> {\r\n                let rtwidth = ((maxDate - minDate)/current.timeLength)*current.width,     //яка буде ширина(px) правої таблиці при такому масштабі\r\n                    k = rtwidth/app.GCBlock.clientWidth;\r\n                //оптимальний масштаб\r\n                if(0.5 < k < 3)\r\n                    app.scaleIndex = i;\r\n                //якщо це буде занадто малий масштаб, робимо його недоступним\r\n                if(k < 0.5)\r\n                    current.disabled = true;\r\n            });\r\n\r\n            this.GCData = {\r\n                startDate: minDate,\r\n                endDate: maxDate,\r\n                minInterval,\r\n                tasks\r\n            };\r\n\r\n            return this.GCData;\r\n        },\r\n\r\n        renderError(errorMsg){\r\n            this.errorBlock.getElementsByClassName(\"error-block__msg\")[0]\r\n                .innerHTML(\"<strong> Сталася помилка <\\/strong> <br>\" + errorMsg.toString());\r\n            this.settingsBlock.classList.add(\"hidden\");\r\n            this.GCBlock.classList.add(\"hidden\");\r\n            this.errorBlock.classList.remove(\"hidden\");\r\n        },\r\n\r\n        renderGanttChart(data) {\r\n            //заповнюємо select з масштабами\r\n            this.scalesDictionary.forEach(scale => {\r\n                this.zoomSelectEl.insertAdjacentHTML(where, html)();\r\n            });\r\n\r\n            //генеруємо масиви з частинами розмітки для діаграми\r\n            let monthTitlesHTMLArr = [],\r\n                dayTitlesHTMLArr = [],\r\n                dayEmptyCellsHTMLArr = [],\r\n                tmpDate = this.GCData.startDate,\r\n                monthNames = ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жоветнь', 'Листопад', 'Грудень'],\r\n                thisMonth;\r\n            do{\r\n                dayTitlesHTMLArr.push(`<th class=\"GC-table__cell GC-table__h-cell GC-table--right__cell--day\">${tmpDate.getDate()}</th>`);\r\n                dayEmptyCellsHTMLArr.push(`<td class=\"GC-table__cell GC-table--right__cell--task-day\"></td>`);\r\n\r\n                if(thisMonth !== tmpDate.getMonth()){\r\n                    thisMonth = tmpDate.getMonth();\r\n                    monthHTMLArr.push(\r\n                        `<th colspan=\"30\" class=\"GC-table__cell GC-table__h-cell GC-table--right__cell--month\">\r\n                            ${monthNames[thisMonth] + \", \" + tmpDate.getFullYear()}\r\n                         </th>`\r\n                    );\r\n                }\r\n\r\n                tmpDate.setDate(tmpDate.getDate()+1);   //збільшуємо день на 1\r\n            }while(tmpDate <= this.GCData.endDate);\r\n\r\n            let lTblBodyChildren = [],\r\n                taskRowsHTML = [],\r\n                fullIntervalL = app.endDate - app.startDate,\r\n                scaleTimeLength = app.scalesDictionary[app.scaleIndex].timeLength,\r\n                cellWidth = app.scalesDictionary[app.scaleIndex].width,\r\n                numOfCells = fullIntervalL/scaleTimeLength;\r\n            this.goThroughTasks(this.GCData.tasks, (task, i) => {\r\n                let paddingLeft = task.level*this.TASK_NAME_PADDING_K;\r\n                lTblBodyChildren.push(\r\n                    `<tr class=\"GC-table__row GC-table--left__row\">\r\n                        <th class=\"GC-table__cell GC-table__h-cell GC-table--left__cell GC-table--left__cell--id\"> ${task.id} </th>\r\n                        <td class=\"GC-table__cell GC-table--left__cell GC-table--left__cell--task-name\" style=\"padding-left:${paddingLeft}px\">\r\n                            ${task.taskName}\r\n                        </td>\r\n                    </tr>`\r\n                );\r\n\r\n                //створюємо DOM-елемент для рядка із задачею\r\n                let taskRow = document.createElement(\"tr\");\r\n                taskRow.classList.add(\"GC-table__row GC-table--right__row GC-table--right__row--task\");\r\n                taskRow.innerHTML(dayEmptyCellsHTMLArr);\r\n\r\n                //заповнюємо рядок із задачею\r\n                task.intervals.forEach( (interval, i) => {\r\n                    let sd = interval.startDate,\r\n                        ed = interval.endDate,\r\n                        intervalL = ed - sd,\r\n                        width = intervalL/fullIntervalL*numOfCells*cellWidth,\r\n                        left = sd/app.startDate*numOfCells*cellWidth;\r\n                    taskRow.childNodes[i].innerHTML = `\r\n                            <td class=\"GC-table__cell GC-table--right__cell--task-day\">\r\n                                <div class=\"GC-table--right__task-stripe\" style=\"width:${width}px; top:${30*i+2}px; left:${left}px; background-color:${interval.color}\"></div>\r\n                            </td>\r\n                    `;\r\n                });\r\n\r\n                taskRowsHTML.push(taskRow);\r\n            });\r\n\r\n            //Розмітка всієї діаграми\r\n            let GCHTMLStr = `\r\n                <div class=\"GC-table-wrapper\">\r\n                    <table class=\"GC-table GC-table--left\">\r\n                        <thead class=\"GC-table__head GC-table--left__head\">\r\n                            <tr class=\"GC-table__row GC-table--left__row GC-table--left__row--head-row\">\r\n                                <th class=\"GC-table__cell GC-table--left__cell GC-table--left__cell--fake\" colspan=\"2\"></th>\r\n                            </tr>\r\n                            <tr class=\"GC-table__row GC-table--left__row GC-table--left__row--head-row\">\r\n                                <th class=\"GC-table__cell GC-table__h-cell GC-table--left__cell\"> ID </th>\r\n                                <th class=\"GC-table__cell GC-table__h-cell GC-table--left__cell\"> Назва задачі </th>\r\n                            </tr>\r\n                        </thead>\r\n                        <tbody>\r\n                            ${lTblBodyChildren.join()}\r\n                        </tbody>\r\n                    </table>\r\n                </div>\r\n                <div class=\"GC-table-wrapper table-responsive\">\r\n                    <table class=\"GC-table GC-table--right\">\r\n                        <thead class=\"GC-table__head GC-table--right__head\">\r\n                            <tr class=\"GC-table__row GC-table--right__row GC-table--right__row--month\">\r\n                                ${monthHTMLArr.join()}\r\n                            </tr>\r\n                            <tr class=\"GC-table__row GC-table--right__row GC-table--right__row--day\">\r\n                                ${dayTitlesHTMLArr.join()}\r\n                            </tr>\r\n                        </thead>\r\n                        <tbody>\r\n                            ${taskRowsHTML.join()}\r\n                        </tbody>\r\n                    </table>\r\n                </div>`;\r\n\r\n            this.GCBlock.dataset.scale = this.scaleIndex;\r\n\r\n            //показуємо діаграму\r\n            this.settingsBlock.classList.remove(\"hidden\");\r\n            this.GCBlock.classList.remove(\"hidden\");\r\n            this.errorBlock.classList.add(\"hidden\");\r\n        }\r\n    };\r\n\r\n    app.initialize();\r\n}() );\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvbWFpbi5qcz8wZjkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCLDhFQUE4RTtBQUMvRixpQkFBaUIsOEVBQThFO0FBQy9GLGlCQUFpQiw4RUFBOEU7QUFDL0YsaUJBQWlCLG9GQUFvRjtBQUNyRyxpQkFBaUIsb0ZBQW9GO0FBQ3JHLGlCQUFpQixrRkFBa0Y7QUFDbkcsaUJBQWlCO0FBQ2pCO0FBQ0EsMENBQTBDOztBQUUxQyxtQ0FBbUMsZ0NBQWdDO0FBQ25FLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxRQUFRO0FBQ3BJOztBQUVBO0FBQ0E7QUFDQSxvR0FBb0csUUFBUTs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvR0FBb0csUUFBUTs7QUFFNUc7QUFDQSx3R0FBd0csUUFBUTs7QUFFaEg7QUFDQTtBQUNBLDBHQUEwRyxRQUFRO0FBQ2xILGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLDBHQUEwRyxRQUFRO0FBQ2xILGlCQUFpQjs7QUFFakI7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQsaUJBQWlCOztBQUVqQixtQ0FBbUM7QUFDbkMsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsa0JBQWtCO0FBQ2xJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxRQUFRO0FBQzdILDhIQUE4SCxZQUFZO0FBQzFJLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLE1BQU0sR0FBRyxPQUFPLE9BQU8sR0FBRyxRQUFRLEtBQUssR0FBRyxvQkFBb0IsZUFBZTtBQUN0SztBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxLIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XHJcbiAgICBsZXQgaGVscGVycyA9IHtcclxuICAgICAgICBybmRDb2xvcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGICkudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGV0IGFwcCA9IHtcclxuICAgICAgICBpbml0aWFsaXplKCkge1xyXG4gICAgICAgICAgICB0aGlzLkdDQmxvY2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIkdDLWJsb2NrXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzQmxvY2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNldHRpbmdzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnpvb21TZWxlY3RFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiem9vbV9fc2VsZWN0XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yQmxvY2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVycm9yLWJsb2NrXCIpO1xyXG5cclxuICAgICAgICAgICAgLy/QvNC+0LbQu9C40LLRliDQvNCw0YHRiNGC0LDQsdC4XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGVzRGljdGlvbmFyeSA9IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCIxMDBweCA6IDEg0LTQtdC90YxcIiwgICAgLy/RgtC10LrRgdGCINGJ0L4g0LHRg9C00LUg0LIg0LXQu9C10LzQtdC90YLRliBzZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICB0aW1lTGVuZ3RoOiAxMDAwKjYwKjYwKjI0LCAgLy/QutC+0LXRhNGW0YbRltGU0L3RgiDRidC+INCy0ZbQtNC/0L7QstGW0LTQsNGUINGH0LDRgdGDXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCwgICAgICAgICAgICAgICAgIC8v0YjQuNGA0LjQvdCwINC60L7QvNGW0YDQutC4INCyIHB4XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlICAgICAgICAgICAgICAvL9GH0Lgg0LTQvtGB0YLRg9C/0L3QuNC5INC80LDRgdGI0YLQsNCxKNGP0LrRidC+INCy0ZbQvSDQt9Cw0L3QsNC00YLQviDQstC10LvQuNC60LjQuSwg0YLQviDQsdGD0LTQtSDQvdC10LTQvtGB0YLRg9C/0L3QuNC8KVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHt0aXRsZTogXCI1MHB4IDogMSDQtNC10L3RjFwiLCB0aW1lTGVuZ3RoOiAxMDAwKjYwKjYwKjI0LCB3aWR0aDogNTAsIGRpc2FibGVkOiBmYWxzZX0sXHJcbiAgICAgICAgICAgICAgICB7dGl0bGU6IFwiMzBweCA6IDEg0LTQtdC90YxcIiwgdGltZUxlbmd0aDogMTAwMCo2MCo2MCoyNCwgd2lkdGg6IDMwLCBkaXNhYmxlZDogZmFsc2V9LFxyXG4gICAgICAgICAgICAgICAge3RpdGxlOiBcIjIwcHggOiAxINC00LXQvdGMXCIsIHRpbWVMZW5ndGg6IDEwMDAqNjAqNjAqMjQsIHdpZHRoOiAyMCwgZGlzYWJsZWQ6IGZhbHNlfSxcclxuICAgICAgICAgICAgICAgIHt0aXRsZTogXCIyMDBweCA6IDEg0LzRltGB0Y/RhtGMXCIsIHRpbWVMZW5ndGg6IDEwMDAqNjAqNjAqMjQqMywgd2lkdGg6IDIwMCwgZGlzYWJsZWQ6IGZhbHNlfSxcclxuICAgICAgICAgICAgICAgIHt0aXRsZTogXCIxMDBweCA6IDEg0LzRltGB0Y/RhtGMXCIsIHRpbWVMZW5ndGg6IDEwMDAqNjAqNjAqMjQqMywgd2lkdGg6IDEwMCwgZGlzYWJsZWQ6IGZhbHNlfSxcclxuICAgICAgICAgICAgICAgIHt0aXRsZTogXCI4MHB4IDogMSDQvNGW0YHRj9GG0YxcIiwgdGltZUxlbmd0aDogMTAwMCo2MCo2MCoyNCozLCB3aWR0aDogODAsIGRpc2FibGVkOiBmYWxzZX0sXHJcbiAgICAgICAgICAgICAgICB7dGl0bGU6IFwiNTBweCA6IDEg0LzRltGB0Y/RhtGMXCIsIHRpbWVMZW5ndGg6IDEwMDAqNjAqNjAqMjQqMywgd2lkdGg6IDUwLCBkaXNhYmxlZDogZmFsc2V9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHRoaXMuVEFTS19OQU1FX1BBRERJTkdfSyA9IDEwOyAgLy/QstGW0LTRgdGC0YPQvyDQvdCwIDEwcHgg0LHRltC70Y8g0ZbQvNC10L3RliDQtNC70Y8g0LrQvtC20L3QvtCz0L4g0YDRltCy0L3RjyDQstC60LvQsNC00LXQvdC+0YHRgtGWXHJcblxyXG4gICAgICAgICAgICB0aGlzLnNjYWxlSW5kZXggPSBudWxsO1x0ICAgIC8v0ZbQvdC00LXQutGBINC+0LHRgNCw0L3QvtCz0L4g0LzQsNGB0YjRgtCw0LHRgzsgbGV0IHNjYWxlID0gYXBwLnNjYWxlc0RpY3Rpb25hcnlbYXBwLnNjYWxlSW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLkdDRGF0YSA9IHsgICAgICAgICAgICAgLy/QtNCw0L3RliDQv9GA0L4g0LTRltCw0LPRgNCw0LzRg1xyXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlOiBudWxsLCAgICAgICAgLy/Qv9C+0YfQsNGC0LrQvtCy0LAg0LTQsNGC0LAg0LLRgdGW0ZTRlyDQtNGW0LDQs9GA0LDQvNC4XHJcbiAgICAgICAgICAgICAgICBlbmREYXRlOiBudWxsLCAgICAgICAgICAvL9C60ZbQvdGG0LXQstCwINC00LDRgtCwINCy0YHRltGU0Zcg0LTRltCw0LPRgNCw0LzQuFxyXG4gICAgICAgICAgICAgICAgbWluSW50ZXJ2YWw6IG51bGwsICAgICAgLy/QvdCw0LnQutC+0YDQvtGC0YjQuNC5INGW0L3RgtC10YDQstCw0Lsg0LfQsNC00LDRh9GWXHJcbiAgICAgICAgICAgICAgICB0YXNrczogW10gICAgICAgICAgICAgICAvL9C80L7QtNC40YTRltC60L7QstCw0L3QuNC5INC80LDRgdC40LIg0LfQsNC00LDRhyDRidC+INC+0YLRgNC40LzRg9GU0YLRjNGB0Y8g0LcgSlNPTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LzRltGB0YLQuNGC0Ywg0YnQtSB0YXNrW2ldLmxldmVsIC0g0YDRltCy0LXQvdGMINCy0LrQu9Cw0LTQtdC90L7RgdGC0ZYo0LrRltC70YzQutGW0YHRgtGMINCx0LDRgtGM0LrRltCyKSB0YXNrW2ldLmludGVydmFzW2pdLmNvbG9yXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldERhdGEoJy90YXNrcy5qc29uJylcclxuICAgICAgICAgICAgICAgIC8vLnRoZW4oIGRhdGEgPT4gY29uc29sZS5sb2coJ0dvdHRlbiBKU09OIHdpdGggdGFza3M6ICcsIEpTT04uc3RyaW5naWZ5KGRhdGEpKSApXHJcbiAgICAgICAgICAgICAgICAudGhlbih0aGlzLnZhbGlkYXRlTW9kZWxEYXRhKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4odGhpcy5ldmFsdWF0ZUFwcERhdGEpXHJcbiAgICAgICAgICAgICAgICAudGhlbih0aGlzLnJlbmRlckdhbnR0Q2hhcnQpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2godGhpcy5yZW5kZXJFcnJvcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFVwTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0VXBMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgdGhpcy5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgdGhpcy5zdWJtaXRGb3JtKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXREYXRhKGpzb25VUkwpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goanNvblVSTClcclxuICAgICAgICAgICAgICAgIC50aGVuKGNoZWNrU3RhdHVzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpICk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja1N0YXR1cyhyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8v0YDQtdC60YPRgNGB0LjQstC90L4g0L7QsdGF0L7QtNC40YLRjCDQvNCw0YHQuNCyIHRhc2tzINGC0LAg0LTQu9GPINC60L7QttC90L7Qs9C+INC10LvQtdC80LXQvdGC0LAg0LLQuNC60LvQuNC60LDRlCBjYlxyXG4gICAgICAgIGdvVGhyb3VnaFRhc2tzKHRhc2tzLCBjYikge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAoZnVuY3Rpb24gX2dvVGhyb3VnaFRhc2tzKHRhc2tzLCBjYiwgZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgdGFzayBvZiB0YXNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IodGFzaywgaW5kZXgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0YXNrLnN1YnRhc2tzICYmIHRhc2suc3VidGFza3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvVGhyb3VnaFRhc2tzKHRhc2suc3VidGFza3MsIGNiLCBkZXB0aCsxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0odGFza3MsIGNiLCAwKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdmFsaWRhdGVNb2RlbERhdGEodGFza3MpIHtcclxuICAgICAgICAgICAgLy/Qv9C10YDQtdCy0ZbRgNC40YLQuCDQstGB0LVcclxuICAgICAgICAgICAgaWYoIXRhc2tzIClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcItCd0LUg0L7RgtGA0LjQvNCw0L3QviDRgdC/0LjRgdC60YMg0LfQsNC00LDRhyDQv9GA0Lgg0YHQv9GA0L7QsdGWINC/0LXRgNC10LLRltGA0LjRgtC4INGX0YUg0L3QsCDQutC+0YDQtdC60YLQvdGW0YHRgtGMLiBcIik7XHJcbiAgICAgICAgICAgIGlmKCEodGFza3MgaW5zdGFuY2VvZiBBcnJheSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCLQntGC0YDQuNC80LDQvdC+INC90LXQutC+0YDQtdC60YLQvdGDINGB0YLRgNGD0LrRgtGD0YDRgyDQtNCw0L3QuNGFINGW0Lcg0LfQsNC00LDRh9Cw0LzQuDog0L7Rh9GW0LrRg9Cy0LDQstGB0Y8g0LzQsNGB0LjQsi5cIik7XHJcblxyXG4gICAgICAgICAgICBsZXQgYXJyT2ZVbmlxdWVJZCA9IFtdO1xyXG4gICAgICAgICAgICBhcHAuZ29UaHJvdWdoVGFza3ModGFza3MsICh0YXNrLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL9C/0LXRgNC10LLRltGA0Y/RlNC80L4g0L3QsCDRg9C90ZbQutCw0LvRjNC90ZbRgdGC0YwgaWRcclxuICAgICAgICAgICAgICAgIGlmKGFyck9mVW5pcXVlSWQuaW5jbHVkZXModGFzay5pZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDQntGC0YDQuNC80LDQvdC+INC90LXQutC+0YDQtdC60YLQvdGDINGB0YLRgNGD0LrRgtGD0YDRgyDQtNCw0L3QuNGFINGW0Lcg0LfQsNC00LDRh9Cw0LzQuDog0L/QvtCy0YLQvtGA0Y7RlNGC0YzRgdGPINGW0LTQtdC90YLQuNGE0ZbQutCw0YLQvtGAINC30LDQtNCw0YcgaWQ9JHt0YXNrLmlkfS5gKTtcclxuICAgICAgICAgICAgICAgIGFyck9mVW5pcXVlSWQucHVzaCh0YXNrLmlkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL9C/0LXRgNC10LLRltGA0Y/RlNC80L4g0L3QsCDQutC+0YDQtdC60YLQvdGW0YHRgtGMINC00LDRgtC4XHJcbiAgICAgICAgICAgICAgICBpZighdGFzay5pbnRlcnZhbHMgKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihg0J7RgtGA0LjQvNCw0L3QviDQvdC10LrQvtGA0LXQutGC0L3RgyDRgdGC0YDRg9C60YLRg9GA0YMg0LTQsNC90LjRhSDRltC3INC30LDQtNCw0YfQsNC80Lg6INC30LDQtNCw0YfQsCDQtyBpZD0ke3Rhc2suaWR9INC90LUg0LzQsNGUINGB0L/QuNGB0LrRgyDQv9C+0YfQsNGC0LrQvtCy0LjRlyDRliDQutGW0L3RhtC10LLQuNGFINC00LDRgi5gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaW52YWxpZERhdGUgPSB0YXNrLmludGVydmFscy5zb21lKHRhc2tEYXRlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNkID0gbmV3IERhdGUodGFza0RhdGUuc3RhcnREYXRlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkID0gbmV3IERhdGUodGFza0RhdGUuZW5kRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZCA9PT0gJ0ludmFsaWQgRGF0ZScgfHwgZWQgPT09ICdJbnZhbGlkIERhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYoaW52YWxpZERhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDQntGC0YDQuNC80LDQvdC+INC90LXQutC+0YDQtdC60YLQvdGDINGB0YLRgNGD0LrRgtGD0YDRgyDQtNCw0L3QuNGFINGW0Lcg0LfQsNC00LDRh9Cw0LzQuDog0LfQsNC00LDRh9CwINC3IGlkPSR7dGFzay5pZH0g0LzQsNGUINC90LXQtNC+0L/Rg9GB0YLQuNC80YMg0LTQsNGC0YMuYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIXRhc2suaW50ZXJ2YWxzLmxlbmd0aCAmJiAhdGFzay5zdWJ0YXNrcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDQntGC0YDQuNC80LDQvdC+INC90LXQutC+0YDQtdC60YLQvdGDINGB0YLRgNGD0LrRgtGD0YDRgyDQtNCw0L3QuNGFINGW0Lcg0LfQsNC00LDRh9Cw0LzQuDog0LTQu9GPINC30LDQtNCw0YfRliDQtyBpZD0ke3Rhc2suaWR9INC80LDRlCDQsdGD0YLQuCDQstC60LDQt9Cw0L3QviDQvdC1INC/0YPRgdGC0LjQuSDRgdC/0LjRgdC+0Log0L/QvtGH0LDRgtC60L7QstC40YUg0ZYg0LrRltC90YbQtdCy0LjRhSDQtNCw0YIsINCw0LHQviDQvdC1INC/0YPRgdGC0LjQuSDRgdC/0LjRgdC+0Log0L/RltC00LfQsNC00LDRh2ApO1xyXG5cclxuICAgICAgICAgICAgICAgIHRhc2suaW50ZXJ2YWxzLmZvckVhY2godGFza0RhdGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5ldyBEYXRlKHRhc2tEYXRlLnN0YXJ0RGF0ZSkgPiBuZXcgRGF0ZSh0YXNrRGF0ZS5lbmREYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDQntGC0YDQuNC80LDQvdC+INC90LXQutC+0YDQtdC60YLQvdGDINGB0YLRgNGD0LrRgtGD0YDRgyDQtNCw0L3QuNGFINGW0Lcg0LfQsNC00LDRh9Cw0LzQuDog0YMg0LfQsNC00LDRh9GWINC3IGlkPSR7dGFzay5pZH0g0LTQsNGC0LAg0L/QvtGH0LDRgtC60YMg0LHRltC70YzRiNCwINC30LAg0LTQsNGC0YMg0LrRltC90YbRjy5gKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRhc2suaW50ZXJ2YWxzLmZvckVhY2godGFza0RhdGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5ldyBEYXRlKHRhc2tEYXRlLmVuZERhdGUpIC0gbmV3IERhdGUodGFza0RhdGUuc3RhcnREYXRlKSA8IDEwMDAqNjAqNjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihg0J7RgtGA0LjQvNCw0L3QviDQvdC10LrQvtGA0LXQutGC0L3RgyDRgdGC0YDRg9C60YLRg9GA0YMg0LTQsNC90LjRhSDRltC3INC30LDQtNCw0YfQsNC80Lg6INGDINC30LDQtNCw0YfRliDQtyBpZD0ke3Rhc2suaWR9INCy0LrQsNC30LDQvdC+INC30LDQvdCw0LTRgtC+INC60L7RgNC+0YLQutC40Lkg0ZbQvdGC0LXRgNCy0LDQuy4g0J/RgNC+0LPRgNCw0LzQsCDQvdC1INC/0ZbQtNGC0YDQuNC80YPRlCDQt9Cw0LTQsNGH0ZYg0Lcg0YLRgNC40LLQsNC70ZbRgdGC0Y4g0LzQtdC90YjQtSAxINCz0L7QtNC40L3QuC5gKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVG9Ebzog0L/QtdGA0LXQstGW0YDQuNGC0Lgg0YfQuCDQv9GW0LTQt9Cw0LTQsNGH0ZYg0L3QtSDQstC40YXQvtC00Y/RgtGMINC30LAg0LTRltCw0L/QsNC30L7QvSDRgtGA0LjQstCw0LvQvtGB0YLRliDQsdCw0YLRjNC60ZbQstGB0YzQutC+0Zcg0LfQsNC00LDRh9GWXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRhc2tzXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy/RgNC+0LfRgNCw0YXQvtCy0YPRlCDRgtCwINCy0YHRgtCw0L3QvtCy0LvRjtGUINC00LDQvdGWINC/0YDQviDRgdGC0LDQvSDQtNC+0LTQsNGC0LrRg1xyXG4gICAgICAgIGV2YWx1YXRlQXBwRGF0YSh0YXNrcykge1xyXG4gICAgICAgICAgICBsZXQgbWluRGF0ZSA9IG5ldyBEYXRlKDEwMDAqNjAqNjAqMjQqMzAqMTIqMTAwMCksXHJcbiAgICAgICAgICAgICAgICBtYXhEYXRlID0gbmV3IERhdGUoMCksXHJcbiAgICAgICAgICAgICAgICBtaW5JbnRlcnZhbCA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICAgICAgYXBwLmdvVGhyb3VnaFRhc2tzKHRhc2tzLCAodGFzaywgaSwgZGVwdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRhc2suaW50ZXJ2YWxzLmZvckVhY2goaW50ZXJ2YWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG1pbkRhdGUgPiBpbnRlcnZhbC5zdGFydERhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRhdGUgPSBpbnRlcnZhbC5zdGFydERhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobWF4RGF0ZSA8IGludGVydmFsLmVuZERhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heERhdGUgPSBpbnRlcnZhbC5lbmREYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcnZhbExlbmd0aCA9IGludGVydmFsLmVuZERhdGUgLSBpbnRlcnZhbC5zdGFydERhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaW50ZXJ2YWxMZW5ndGggPCBtaW5JbnRlcnZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluSW50ZXJ2YWwgPSBpbnRlcnZhbExlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwuY29sb3IgPSBoZWxwZXJzLnJuZENvbG9yKCk7ICAgLy/Qt9Cw0LTQsNGU0LzQviDQutC+0LvRltGAINC/0L7Qu9C+0YHQutC4INC00LvRjyDQutC+0LbQvdC+0LPQviDRltC90YLQtdGA0LLQsNC70YNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRhc2subGV2ZWwgPSBkZXB0aDsgICAgIC8v0LfQsNC/0LDQvCfRj9GC0L7QstGD0ZTQvNC+INGA0ZbQstC10L3RjCDQstGW0LTRgdGC0YPQv9GDKNGP0LrQuNC5INC60YDQsNGC0L3QuNC5INC60ZbQu9GM0LrQvtGB0YLRliDQsdCw0YLRjNC60ZbQsikg0LTQu9GPINC60L7QttC90L7RlyDQt9Cw0LTQsNGH0ZZcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvL9Cy0LjRgNCw0YXQvtCy0YPRlNC80L4g0L7Qv9GC0LjQvNCw0LvRjNC90LjQuSDRgtCwINC00L7Qv9GD0YHRgtC40LzRliDQvNCw0YHRiNGC0LDQsdC4XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGVzRGljdGlvbmFyeS5yZWR1Y2UoKGJlc3QsIGN1cnJlbnQsIGkpPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJ0d2lkdGggPSAoKG1heERhdGUgLSBtaW5EYXRlKS9jdXJyZW50LnRpbWVMZW5ndGgpKmN1cnJlbnQud2lkdGgsICAgICAvL9GP0LrQsCDQsdGD0LTQtSDRiNC40YDQuNC90LAocHgpINC/0YDQsNCy0L7RlyDRgtCw0LHQu9C40YbRliDQv9GA0Lgg0YLQsNC60L7QvNGDINC80LDRgdGI0YLQsNCx0ZZcclxuICAgICAgICAgICAgICAgICAgICBrID0gcnR3aWR0aC9hcHAuR0NCbG9jay5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgIC8v0L7Qv9GC0LjQvNCw0LvRjNC90LjQuSDQvNCw0YHRiNGC0LDQsVxyXG4gICAgICAgICAgICAgICAgaWYoMC41IDwgayA8IDMpXHJcbiAgICAgICAgICAgICAgICAgICAgYXBwLnNjYWxlSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgLy/Rj9C60YnQviDRhtC1INCx0YPQtNC1INC30LDQvdCw0LTRgtC+INC80LDQu9C40Lkg0LzQsNGB0YjRgtCw0LEsINGA0L7QsdC40LzQviDQudC+0LPQviDQvdC10LTQvtGB0YLRg9C/0L3QuNC8XHJcbiAgICAgICAgICAgICAgICBpZihrIDwgMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuR0NEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlOiBtaW5EYXRlLFxyXG4gICAgICAgICAgICAgICAgZW5kRGF0ZTogbWF4RGF0ZSxcclxuICAgICAgICAgICAgICAgIG1pbkludGVydmFsLFxyXG4gICAgICAgICAgICAgICAgdGFza3NcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkdDRGF0YTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW5kZXJFcnJvcihlcnJvck1zZyl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCbG9jay5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZXJyb3ItYmxvY2tfX21zZ1wiKVswXVxyXG4gICAgICAgICAgICAgICAgLmlubmVySFRNTChcIjxzdHJvbmc+INCh0YLQsNC70LDRgdGPINC/0L7QvNC40LvQutCwIDxcXC9zdHJvbmc+IDxicj5cIiArIGVycm9yTXNnLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzQmxvY2suY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcclxuICAgICAgICAgICAgdGhpcy5HQ0Jsb2NrLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCbG9jay5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbmRlckdhbnR0Q2hhcnQoZGF0YSkge1xyXG4gICAgICAgICAgICAvL9C30LDQv9C+0LLQvdGO0ZTQvNC+IHNlbGVjdCDQtyDQvNCw0YHRiNGC0LDQsdCw0LzQuFxyXG4gICAgICAgICAgICB0aGlzLnNjYWxlc0RpY3Rpb25hcnkuZm9yRWFjaChzY2FsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21TZWxlY3RFbC5pbnNlcnRBZGphY2VudEhUTUwod2hlcmUsIGh0bWwpKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy/Qs9C10L3QtdGA0YPRlNC80L4g0LzQsNGB0LjQstC4INC3INGH0LDRgdGC0LjQvdCw0LzQuCDRgNC+0LfQvNGW0YLQutC4INC00LvRjyDQtNGW0LDQs9GA0LDQvNC4XHJcbiAgICAgICAgICAgIGxldCBtb250aFRpdGxlc0hUTUxBcnIgPSBbXSxcclxuICAgICAgICAgICAgICAgIGRheVRpdGxlc0hUTUxBcnIgPSBbXSxcclxuICAgICAgICAgICAgICAgIGRheUVtcHR5Q2VsbHNIVE1MQXJyID0gW10sXHJcbiAgICAgICAgICAgICAgICB0bXBEYXRlID0gdGhpcy5HQ0RhdGEuc3RhcnREYXRlLFxyXG4gICAgICAgICAgICAgICAgbW9udGhOYW1lcyA9IFsn0KHRltGH0LXQvdGMJywgJ9Cb0Y7RgtC40LknLCAn0JHQtdGA0LXQt9C10L3RjCcsICfQmtCy0ZbRgtC10L3RjCcsICfQotGA0LDQstC10L3RjCcsICfQp9C10YDQstC10L3RjCcsICfQm9C40L/QtdC90YwnLCAn0KHQtdGA0L/QtdC90YwnLCAn0JLQtdGA0LXRgdC10L3RjCcsICfQltC+0LLQtdGC0L3RjCcsICfQm9C40YHRgtC+0L/QsNC0JywgJ9CT0YDRg9C00LXQvdGMJ10sXHJcbiAgICAgICAgICAgICAgICB0aGlzTW9udGg7XHJcbiAgICAgICAgICAgIGRve1xyXG4gICAgICAgICAgICAgICAgZGF5VGl0bGVzSFRNTEFyci5wdXNoKGA8dGggY2xhc3M9XCJHQy10YWJsZV9fY2VsbCBHQy10YWJsZV9faC1jZWxsIEdDLXRhYmxlLS1yaWdodF9fY2VsbC0tZGF5XCI+JHt0bXBEYXRlLmdldERhdGUoKX08L3RoPmApO1xyXG4gICAgICAgICAgICAgICAgZGF5RW1wdHlDZWxsc0hUTUxBcnIucHVzaChgPHRkIGNsYXNzPVwiR0MtdGFibGVfX2NlbGwgR0MtdGFibGUtLXJpZ2h0X19jZWxsLS10YXNrLWRheVwiPjwvdGQ+YCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhpc01vbnRoICE9PSB0bXBEYXRlLmdldE1vbnRoKCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNNb250aCA9IHRtcERhdGUuZ2V0TW9udGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBtb250aEhUTUxBcnIucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgYDx0aCBjb2xzcGFuPVwiMzBcIiBjbGFzcz1cIkdDLXRhYmxlX19jZWxsIEdDLXRhYmxlX19oLWNlbGwgR0MtdGFibGUtLXJpZ2h0X19jZWxsLS1tb250aFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHttb250aE5hbWVzW3RoaXNNb250aF0gKyBcIiwgXCIgKyB0bXBEYXRlLmdldEZ1bGxZZWFyKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPmBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRtcERhdGUuc2V0RGF0ZSh0bXBEYXRlLmdldERhdGUoKSsxKTsgICAvL9C30LHRltC70YzRiNGD0ZTQvNC+INC00LXQvdGMINC90LAgMVxyXG4gICAgICAgICAgICB9d2hpbGUodG1wRGF0ZSA8PSB0aGlzLkdDRGF0YS5lbmREYXRlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBsVGJsQm9keUNoaWxkcmVuID0gW10sXHJcbiAgICAgICAgICAgICAgICB0YXNrUm93c0hUTUwgPSBbXSxcclxuICAgICAgICAgICAgICAgIGZ1bGxJbnRlcnZhbEwgPSBhcHAuZW5kRGF0ZSAtIGFwcC5zdGFydERhdGUsXHJcbiAgICAgICAgICAgICAgICBzY2FsZVRpbWVMZW5ndGggPSBhcHAuc2NhbGVzRGljdGlvbmFyeVthcHAuc2NhbGVJbmRleF0udGltZUxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCA9IGFwcC5zY2FsZXNEaWN0aW9uYXJ5W2FwcC5zY2FsZUluZGV4XS53aWR0aCxcclxuICAgICAgICAgICAgICAgIG51bU9mQ2VsbHMgPSBmdWxsSW50ZXJ2YWxML3NjYWxlVGltZUxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5nb1Rocm91Z2hUYXNrcyh0aGlzLkdDRGF0YS50YXNrcywgKHRhc2ssIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBwYWRkaW5nTGVmdCA9IHRhc2subGV2ZWwqdGhpcy5UQVNLX05BTUVfUEFERElOR19LO1xyXG4gICAgICAgICAgICAgICAgbFRibEJvZHlDaGlsZHJlbi5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIGA8dHIgY2xhc3M9XCJHQy10YWJsZV9fcm93IEdDLXRhYmxlLS1sZWZ0X19yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwiR0MtdGFibGVfX2NlbGwgR0MtdGFibGVfX2gtY2VsbCBHQy10YWJsZS0tbGVmdF9fY2VsbCBHQy10YWJsZS0tbGVmdF9fY2VsbC0taWRcIj4gJHt0YXNrLmlkfSA8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJHQy10YWJsZV9fY2VsbCBHQy10YWJsZS0tbGVmdF9fY2VsbCBHQy10YWJsZS0tbGVmdF9fY2VsbC0tdGFzay1uYW1lXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6JHtwYWRkaW5nTGVmdH1weFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHt0YXNrLnRhc2tOYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+YFxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL9GB0YLQstC+0YDRjtGU0LzQviBET00t0LXQu9C10LzQtdC90YIg0LTQu9GPINGA0Y/QtNC60LAg0ZbQtyDQt9Cw0LTQsNGH0LXRjlxyXG4gICAgICAgICAgICAgICAgbGV0IHRhc2tSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIik7XHJcbiAgICAgICAgICAgICAgICB0YXNrUm93LmNsYXNzTGlzdC5hZGQoXCJHQy10YWJsZV9fcm93IEdDLXRhYmxlLS1yaWdodF9fcm93IEdDLXRhYmxlLS1yaWdodF9fcm93LS10YXNrXCIpO1xyXG4gICAgICAgICAgICAgICAgdGFza1Jvdy5pbm5lckhUTUwoZGF5RW1wdHlDZWxsc0hUTUxBcnIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8v0LfQsNC/0L7QstC90Y7RlNC80L4g0YDRj9C00L7QuiDRltC3INC30LDQtNCw0YfQtdGOXHJcbiAgICAgICAgICAgICAgICB0YXNrLmludGVydmFscy5mb3JFYWNoKCAoaW50ZXJ2YWwsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2QgPSBpbnRlcnZhbC5zdGFydERhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkID0gaW50ZXJ2YWwuZW5kRGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxMID0gZWQgLSBzZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbnRlcnZhbEwvZnVsbEludGVydmFsTCpudW1PZkNlbGxzKmNlbGxXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNkL2FwcC5zdGFydERhdGUqbnVtT2ZDZWxscypjZWxsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFza1Jvdy5jaGlsZE5vZGVzW2ldLmlubmVySFRNTCA9IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIkdDLXRhYmxlX19jZWxsIEdDLXRhYmxlLS1yaWdodF9fY2VsbC0tdGFzay1kYXlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiR0MtdGFibGUtLXJpZ2h0X190YXNrLXN0cmlwZVwiIHN0eWxlPVwid2lkdGg6JHt3aWR0aH1weDsgdG9wOiR7MzAqaSsyfXB4OyBsZWZ0OiR7bGVmdH1weDsgYmFja2dyb3VuZC1jb2xvcjoke2ludGVydmFsLmNvbG9yfVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICBgO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGFza1Jvd3NIVE1MLnB1c2godGFza1Jvdyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy/QoNC+0LfQvNGW0YLQutCwINCy0YHRltGU0Zcg0LTRltCw0LPRgNCw0LzQuFxyXG4gICAgICAgICAgICBsZXQgR0NIVE1MU3RyID0gYFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIkdDLXRhYmxlLXdyYXBwZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJHQy10YWJsZSBHQy10YWJsZS0tbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQgY2xhc3M9XCJHQy10YWJsZV9faGVhZCBHQy10YWJsZS0tbGVmdF9faGVhZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVwiR0MtdGFibGVfX3JvdyBHQy10YWJsZS0tbGVmdF9fcm93IEdDLXRhYmxlLS1sZWZ0X19yb3ctLWhlYWQtcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwiR0MtdGFibGVfX2NlbGwgR0MtdGFibGUtLWxlZnRfX2NlbGwgR0MtdGFibGUtLWxlZnRfX2NlbGwtLWZha2VcIiBjb2xzcGFuPVwiMlwiPjwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVwiR0MtdGFibGVfX3JvdyBHQy10YWJsZS0tbGVmdF9fcm93IEdDLXRhYmxlLS1sZWZ0X19yb3ctLWhlYWQtcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwiR0MtdGFibGVfX2NlbGwgR0MtdGFibGVfX2gtY2VsbCBHQy10YWJsZS0tbGVmdF9fY2VsbFwiPiBJRCA8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cIkdDLXRhYmxlX19jZWxsIEdDLXRhYmxlX19oLWNlbGwgR0MtdGFibGUtLWxlZnRfX2NlbGxcIj4g0J3QsNC30LLQsCDQt9Cw0LTQsNGH0ZYgPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7bFRibEJvZHlDaGlsZHJlbi5qb2luKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIkdDLXRhYmxlLXdyYXBwZXIgdGFibGUtcmVzcG9uc2l2ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cIkdDLXRhYmxlIEdDLXRhYmxlLS1yaWdodFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQgY2xhc3M9XCJHQy10YWJsZV9faGVhZCBHQy10YWJsZS0tcmlnaHRfX2hlYWRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cIkdDLXRhYmxlX19yb3cgR0MtdGFibGUtLXJpZ2h0X19yb3cgR0MtdGFibGUtLXJpZ2h0X19yb3ctLW1vbnRoXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHttb250aEhUTUxBcnIuam9pbigpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cIkdDLXRhYmxlX19yb3cgR0MtdGFibGUtLXJpZ2h0X19yb3cgR0MtdGFibGUtLXJpZ2h0X19yb3ctLWRheVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZGF5VGl0bGVzSFRNTEFyci5qb2luKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3Rhc2tSb3dzSFRNTC5qb2luKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PmA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLkdDQmxvY2suZGF0YXNldC5zY2FsZSA9IHRoaXMuc2NhbGVJbmRleDtcclxuXHJcbiAgICAgICAgICAgIC8v0L/QvtC60LDQt9GD0ZTQvNC+INC00ZbQsNCz0YDQsNC80YNcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Jsb2NrLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuR0NCbG9jay5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yQmxvY2suY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFwcC5pbml0aWFsaXplKCk7XHJcbn0oKSApO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvanMvbWFpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = global.fetch;\n}.call(global));\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qcz9jYmEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLDBCQUEwQixlQUFlO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDLGUiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbihmdW5jdGlvbigpIHtcblxuKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW25hbWVdXG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gW11cbiAgICAgIHRoaXMubWFwW25hbWVdID0gbGlzdFxuICAgIH1cbiAgICBsaXN0LnB1c2godmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gICAgcmV0dXJuIHZhbHVlcyA/IHZhbHVlc1swXSA6IG51bGxcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gfHwgW11cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBbbm9ybWFsaXplVmFsdWUodmFsdWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5tYXApLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5tYXBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKVxuICAgICAgfSwgdGhpcylcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydCBBcnJheUJ1ZmZlcnMgZm9yIFBPU1QgbWV0aG9kLlxuICAgICAgICAvLyBSZWNlaXZpbmcgQXJyYXlCdWZmZXJzIGhhcHBlbnMgdmlhIEJsb2JzLCBpbnN0ZWFkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkIDogUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuICAgIGlmIChSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IGlucHV0XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCdcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSlcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhlYWRlcnMoeGhyKSB7XG4gICAgdmFyIGhlYWQgPSBuZXcgSGVhZGVycygpXG4gICAgdmFyIHBhaXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzKSA/IDIwNCA6IHhoci5zdGF0dXNcbiAgICAgICAgaWYgKHN0YXR1cyA8IDEwMCB8fCBzdGF0dXMgPiA1OTkpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMoeGhyKSxcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlVVJMKClcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cblxuLyoqKiBFWFBPUlRTIEZST00gZXhwb3J0cy1sb2FkZXIgKioqL1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZmV0Y2g7XG59LmNhbGwoZ2xvYmFsKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaW1wb3J0cy1sb2FkZXI/dGhpcz0+Z2xvYmFsIS4vfi9leHBvcnRzLWxvYWRlcj9nbG9iYWwuZmV0Y2ghLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);